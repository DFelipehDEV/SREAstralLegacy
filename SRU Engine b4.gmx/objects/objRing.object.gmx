<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprRing</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    // ----- Variables ----------------------------------------

    collected = false;

    attracted = false;
    motion  =   false;          // Is the ring in movement?
    speedX  =   0;              // X and Y speeds of the ring
    speedY  =   0;              
    
    gravityForce = 0.2;         // How does the gravity affect to this? &gt;_&lt;

    timer   =   0;              // For making the rings disappear
    flash   =   true;           // For the flashing effect
    
    image_speed = 0.3;          // Image speed, for animation :)
    image_alpha = 1;
    
    distance_to_player = 0;
    angle_to_player    = 0;
shield=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    if (collected) instance_create(x, y, objRingDie);</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    /* The ring motion itself is fairly easy and shouldn't be any kind of
       problem. Move the ring, then if it was stuck, bounce and go to the
       previous x. The same for the Y movement.

       Also, there's a timer witch when it goes to 0, destroys the ring.
       (only if it's in motion)
    */

    // ---- Get attracted by player --------------------
    
    // Check if rings should be attracted
    if !instance_exists(objSonic) exit;
    
    if image_alpha&lt;0{
    instance_destroy()
    }
    
           // If so, go towards the player
    if ( attracted == true ) 
    {        
        angle_to_player = degtorad(point_direction(x, y, objPlayer.x, objPlayer.y));
        
        speedX = min(60, max(-70, speedX+cos(angle_to_player)*0.7));
        speedY = min(60, max(-70, speedY-sin(angle_to_player)*0.7));
    }
    
    if (objPlayer != noone)
    {
        if (objPlayer.boosting || objPlayer.shield=3)
        {
            distance_to_player = distance_to_object(objPlayer);
            if (distance_to_player &lt; 55){attracted=true}
    }
    }

    // ---- Move if it is in motion --------------------

    // Apply X motion
    x += speedX + cos(angle_to_player)*attracted;

    if ( motion == true )
    {

        // Unstuck and bounce if it collides with the walls
        mask_index = maskRingLR;
        if ( (speedX &gt; 0 &amp;&amp; place_meeting( x + 6, y, objSolid )) ||
             (speedX &lt; 0 &amp;&amp; place_meeting( x - 6, y, objSolid )) )
        {
            // Unstick from the wall
            x -= speedX;            
            // Bounce, losening strenght
            speedX = -speedX * 0.9;
        }
    }

    // Apply Y motion
    y += speedY - sin(angle_to_player)*attracted;
    
    if ( motion == true )
    {        
        // Unstuck and bounce if it collides with the walls
        mask_index = maskRingUD;
        if ( (speedY &gt; 0 &amp;&amp; place_meeting( x, y + 6, objSolid )) ||
             (speedY &lt; 0 &amp;&amp; place_meeting( x, y - 6, objSolid )) )
        {
            // Unstick from the wall
            y -= speedY;            
            // Bounce, losening strenght
            speedY = -speedY * 0.9;
        }
                
        // Apply gravity force
        speedY += gravityForce;
        
        if ( timer &gt; 0  ) timer -= 1;
        if ( timer &lt; 20 ) image_alpha-=0.05
    }

    image_index = global.game_time div 40;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    // Check if the ring is in movement and the timer is less than 90     
    if ( motion == true &amp;&amp; timer &lt; 20 )
    {
        // Here we'll just going to do a little trick. We need to check
        // if the rings needs to be drawn every X time. Since each frame
        // should be blinking us, we divide the timer between 2 to make the
        // timer stay longer in a number (dirty trick #1) and then calculate
        // the modulus (the remainder) for checking if it's pair or not.
        //
        // If it is, just draw the sprite
 draw_self()
    } 
    else 
    {
        // Otherwise, draw normally
        draw_sprite ( sprRing, floor(image_index), x, y );
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
